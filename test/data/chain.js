const res = this.syntax.startNewSubset(letter, letterSet, word, words, sentence.substring(letter.length), debug, subset);
return this.syntax.findTriggers(subset[path[path.length - 1]], path.slice(1));
let a = save.content.remove({
    sLine : min,
    len   : Math.max(...keys) - min + 1,
}) - 2

Object.keys(required).forEach( attr => {
    set[attr] = typeof set[attr] == 'undefined' ? required[attr] : set[attr];
});
 string = string.replaceAll(' ', '&nbsp;').replaceAll(this.spaceUChar, '&nbsp;');

subset[path[path.length-1]] path.slice(1);
let obj = {
    'sa' : 'v',
  g : () => {},
  c : {
  	sddf : {
  		asas: {
  			we_das : {

				}
			}
		}
	}
}

obj.
ba = 'c';
obj
.sa = 'g'
obj.sa = 'a'
obj.p = 2  +1;
obj.g()
obj.c.sddf.asas
obj.c.sddf.asas.we_das['@varp2']()
obj.c.sddf["asa"] = 123;
obj.c.sddf["asa"].asd;
methodsSave.forEach(path => {
  this.set.preciseMethodsProxy(this, path);
});

if ( sel.type.toLowerCase() == 'range' ) {
  startLine = main.selection.start.line;
  if ( main.selection.start.line > main.selection.end.line ) {
    startLine = main.selection.end.line;
  }
}


methodsSave.forEach(path => {
  this.set.preciseMethodsProxy(this, path);
});
this.render.content[ this.pos.line ].content = this.truck.exportLine( el.parentElement ).content;

variable++
this.pos.line--;
--this.pos.line;

pos.dot--
dot.pos;
dot.pos -= 1;


pos['dot']--
dot['pos']
this.syntax.groups[0].end[sentence[0]]
