Mapping...
Letter: f Mapped Word: f
Letter: u Mapped Word: fu
Letter: n Mapped Word: fun
Letter: c Mapped Word: func
Letter: t Mapped Word: funct
Letter: i Mapped Word: functi
Letter: o Mapped Word: functio
Letter: n Mapped Word: function
Letter:   Mapped Word: function 
  New block: Method Mapped by: function 
  Letter:   end chars: {
  Letter: t end chars: {
  Letter: e end chars: {
  Letter: s end chars: {
  Letter: t end chars: {
  Letter: ( end chars: {
  Letter: ) end chars: {
  Letter:   end chars: {
  Letter: { end chars: {
  Proper end : 16
  Start name search: function test() {, 8
    Letter:  
    Letter: t
    Letter: e
    Letter: s
    Letter: t
    Letter: (
    Blocks name: test
  Letter:   Mapped Word:  
  Letter: v Mapped Word: v
  Letter: a Mapped Word: va
  Letter: r Mapped Word: var
  Letter:   Mapped Word: var 
    New block: Variable Mapped by: var 
    Letter:   end chars: =
    Letter: l end chars: =
    Letter: o end chars: =
    Letter: n end chars: =
    Letter: g end chars: =
    Letter: N end chars: =
    Letter: a end chars: =
    Letter: m end chars: =
    Letter: e end chars: =
    Letter:   end chars: =
    Letter: = end chars: =
    Proper end : 31
    Found instruction: var longName =
    Letter:   Mapped Word:  
    Letter: 2 Mapped Word: 2
    Letter: 0 Mapped Word: 0
    Letter: ; Mapped Word: ;
    Updated caret 35
    Start name search: var longName =, 3
      Letter:  
      Letter: l
      Letter: o
      Letter: n
      Letter: g
      Letter: N
      Letter: a
      Letter: m
      Letter: e
      Letter:  
      Letter: =
      Blocks name: longName
    Iteration count changed from 21 to 35
    Instruction: `var longName =`
  Letter: \n Mapped Word: \n
  Undefined check for: \n
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter: c Mapped Word: c
  Letter: o Mapped Word: co
  Letter: n Mapped Word: con
  Letter: s Mapped Word: cons
  Letter: o Mapped Word: conso
  Letter: l Mapped Word: l
  Letter: e Mapped Word: le
  Letter: . Mapped Word: le.
    New block: ChainLink Mapped by: le.
    Find start of instruction. End: 48
    Letter: e
    Letter: l
    Letter: o
    Letter: s
    Letter: n
    Letter: o
    Letter: c
    Letter:  
    Proper start : 40
    Start search for end of link
      Letter: l
      Letter: o
      Letter: g
      Letter: (
      End found: (
    Instruction: log
    Letter:   Mapped Word:  
    Letter: l Mapped Word: l
    Letter: o Mapped Word: lo
    Letter: n Mapped Word: n
    Letter: g Mapped Word: ng
    Letter: N Mapped Word: N
    Letter: a Mapped Word: a
    Letter: m Mapped Word: m
    Letter: e Mapped Word: e
    Letter: ) Mapped Word: )
    Add undefined:  longName
    Updated caret 62
    Iteration count changed from 48 to 62
    Instruction: `log`
  Letter: ; Mapped Word: ;
  Undefined check for: ;
  Letter: \n Mapped Word: \n
  Undefined check for: \n
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter: c Mapped Word: c
  Letter: o Mapped Word: co
  Letter: n Mapped Word: con
  Letter: s Mapped Word: cons
  Letter: t Mapped Word: const
  Letter:   Mapped Word: const 
    New block: Variable Mapped by: const 
    Letter:   end chars: =
    Letter: t end chars: =
    Letter: e end chars: =
    Letter: s end chars: =
    Letter: t end chars: =
    Letter: a end chars: =
    Letter:   end chars: =
    Letter: = end chars: =
    Proper end : 81
    Found instruction: const testa =
    Letter:   Mapped Word:  
    Letter: ( Mapped Word: (
      New block: Caller Mapped by: (
      Iteration count changed from 83 to 83
      Instruction: ``
    Letter: a Mapped Word: a
    Letter: r Mapped Word: r
    Letter: g Mapped Word: g
    Letter: 1 Mapped Word: 1
    Letter: ) Mapped Word: )
    Letter:   Mapped Word:  
    Letter: = Mapped Word: =
    Letter: > Mapped Word: =>
      New block: ArrowMethod Mapped by: =>
      New Arrow method
        New letter ` `
        New letter `)`
        Start search for brackets
        New letter `1`
        Start search for whitspace, letter found before bracket
        New letter `g`
        New letter `r`
        New letter `a`
        New letter `(`
        Bracket found
      Start search for end
        Letter  
        Letter {
        Letter is bracket! Multi line function.
      Letter: \n Mapped Word: \n
      Undefined check for: \n
      Letter:   Mapped Word:  
      Letter:   Mapped Word:  
      Letter:   Mapped Word:  
      Letter:   Mapped Word:  
      Letter:   Mapped Word:  
      Letter:   Mapped Word:  
      Letter:   Mapped Word:  
      Letter:   Mapped Word:  
      Letter: c Mapped Word: c
      Letter: o Mapped Word: co
      Letter: n Mapped Word: con
      Letter: s Mapped Word: cons
      Letter: t Mapped Word: const
      Letter:   Mapped Word: const 
        New block: Variable Mapped by: const 
        Letter:   end chars: =
        Letter:   end chars: =
        Letter:   end chars: =
        Letter: t end chars: =
        Letter: e end chars: =
        Letter: s end chars: =
        Letter: t end chars: =
        Letter: S end chars: =
        Letter: c end chars: =
        Letter: o end chars: =
        Letter: p end chars: =
        Letter: e end chars: =
        Letter: d end chars: =
        Letter:   end chars: =
        Letter: = end chars: =
        Proper end : 122
        Found instruction: const testScoped =
        Letter:   Mapped Word:  
        Letter: f Mapped Word: f
        Letter: u Mapped Word: fu
        Letter: n Mapped Word: fun
        Letter: c Mapped Word: func
        Letter: t Mapped Word: funct
        Letter: i Mapped Word: functi
        Letter: o Mapped Word: functio
        Letter: n Mapped Word: function
        Letter:   Mapped Word: function 
          New block: Method Mapped by: function 
          Letter:   end chars: {
          Letter: ( end chars: {
          Letter: a end chars: {
          Letter: d end chars: {
          Letter: a end chars: {
          Letter: s end chars: {
          Letter: , end chars: {
          Letter:   end chars: {
          Letter: t end chars: {
          Letter: e end chars: {
          Letter: s end chars: {
          Letter: t end chars: {
          Letter: 5 end chars: {
          Letter:   end chars: {
          Letter:   end chars: {
          Letter:   end chars: {
          Letter: , end chars: {
          Letter:   end chars: {
          Letter:   end chars: {
          Letter: t end chars: {
          Letter: e end chars: {
          Letter: s end chars: {
          Letter: t end chars: {
          Letter: 4 end chars: {
          Letter: , end chars: {
          Letter: \n end chars: {
          Letter:   end chars: {
          Letter:   end chars: {
          Letter:   end chars: {
          Letter:   end chars: {
          Letter:   end chars: {
          Letter:   end chars: {
          Letter:   end chars: {
          Letter:   end chars: {
          Letter: f end chars: {
          Letter: g end chars: {
          Letter: d end chars: {
          Letter: f end chars: {
          Letter: g end chars: {
          Letter: ) end chars: {
          Letter:   end chars: {
          Letter: { end chars: {
          Proper end : 173
          Start name search: function (adas, test5 , test4, fgdfg) {, 8
            Letter:  
            Letter: (
            Blocks name: 
          Letter: \n Mapped Word: \n
          Undefined check for: \n
          Letter: \n Mapped Word: \n
          Undefined check for: \n
          Letter:   Mapped Word:  
          Letter:   Mapped Word:  
          Letter:   Mapped Word:  
          Letter:   Mapped Word:  
          Letter:   Mapped Word:  
          Letter:   Mapped Word:  
          Letter:   Mapped Word:  
          Letter:   Mapped Word:  
          Letter: } Mapped Word: }
          Updated caret 184
          Iteration count changed from 132 to 184
          Instruction: `function (adas, test5 , test4, fgdfg) {`
        Letter: \n Mapped Word: \n
        Updated caret 185
        Start name search: const testScoped =, 5
          Letter:  
          Letter: t
          Letter: e
          Letter: s
          Letter: t
          Letter: S
          Letter: c
          Letter: o
          Letter: p
          Letter: e
          Letter: d
          Letter:  
          Letter: =
          Blocks name: testScoped
        Iteration count changed from 108 to 185
        Instruction: `const testScoped =`
      Letter:   Mapped Word:  
      Letter:   Mapped Word:  
      Letter:   Mapped Word:  
      Letter:   Mapped Word:  
      Letter: } Mapped Word: }
      Updated caret 190
        Letter: (, Word: 
        Start parenthesis search
        Letter: a, Word: 
        Letter: r, Word: a
        Letter: g, Word: ar
        Letter: 1, Word: arg
        Letter: ), Word: arg1
        Stop search for parenthesis
      Iteration count changed from 91 to 190
      Instruction: `(arg1) => {`
    Letter: ; Mapped Word: ;
    Updated caret 191
    Start name search: const testa =, 5
      Letter:  
      Letter: t
      Letter: e
      Letter: s
      Letter: t
      Letter: a
      Letter:  
      Letter: =
      Blocks name: testa
    Iteration count changed from 74 to 191
    Instruction: `const testa =`
  Letter: \n Mapped Word: \n
  Undefined check for: \n
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter: c Mapped Word: c
  Letter: o Mapped Word: co
  Letter: n Mapped Word: con
  Letter: s Mapped Word: cons
  Letter: t Mapped Word: const
  Letter:   Mapped Word: const 
    New block: Variable Mapped by: const 
    Letter:   end chars: =
    Letter: t end chars: =
    Letter: e end chars: =
    Letter: s end chars: =
    Letter: t end chars: =
    Letter: 2 end chars: =
    Letter:   end chars: =
    Letter: = end chars: =
    Proper end : 209
    Found instruction: const test2 =
    Letter:   Mapped Word:  
    Letter: e Mapped Word: e
    Letter:   Mapped Word:  
    Letter: = Mapped Word: =
    Letter: > Mapped Word: =>
      New block: ArrowMethod Mapped by: =>
      New Arrow method
        New letter ` `
        New letter `e`
        Start search for whitspace, letter found before bracket
        New letter ` `
        White space found
      Start search for end
        Letter  
        Letter 1
        Found non white space and not bracket. One line arrow method
        Letter  
        Letter +
        Letter  
        Letter 2
        Letter ;
        End char found, setting the end...
        Letter: e, Word: 
        function has only one arg, start search for it...
        Letter:  , Word: e
        Whitespace!
        Found next whitespace, add arg and end iteration
      Iteration count changed from 214 to 220
      Instruction: `e =>`
    Letter: ; Mapped Word: ;
    Updated caret 221
    Start name search: const test2 =, 5
      Letter:  
      Letter: t
      Letter: e
      Letter: s
      Letter: t
      Letter: 2
      Letter:  
      Letter: =
      Blocks name: test2
    Iteration count changed from 202 to 221
    Instruction: `const test2 =`
  Letter: \n Mapped Word: \n
  Undefined check for: \n
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter: c Mapped Word: c
  Letter: o Mapped Word: co
  Letter: n Mapped Word: con
  Letter: s Mapped Word: cons
  Letter: t Mapped Word: const
  Letter:   Mapped Word: const 
    New block: Variable Mapped by: const 
    Letter:   end chars: =
    Letter: t end chars: =
    Letter: e end chars: =
    Letter: s end chars: =
    Letter: t end chars: =
    Letter: 3 end chars: =
    Letter:   end chars: =
    Letter: = end chars: =
    Proper end : 239
    Found instruction: const test3 =
    Letter:   Mapped Word:  
    Letter: ( Mapped Word: (
      New block: Caller Mapped by: (
      Iteration count changed from 241 to 241
      Instruction: ``
    Letter: e Mapped Word: e
    Letter: 2 Mapped Word: 2
    Letter: ) Mapped Word: )
    Letter:   Mapped Word:  
    Letter: = Mapped Word: =
    Letter: > Mapped Word: =>
      New block: ArrowMethod Mapped by: =>
      New Arrow method
        New letter ` `
        New letter `)`
        Start search for brackets
        New letter `2`
        Start search for whitspace, letter found before bracket
        New letter `e`
        New letter `(`
        Bracket found
      Start search for end
        Letter \n
        Letter  
        Letter  
        Letter  
        Letter  
        Letter 1
        Found non white space and not bracket. One line arrow method
        Letter  
        Letter +
        Letter  
        Letter e
        Letter 2
        Letter ;
        End char found, setting the end...
        Letter: (, Word: 
        Start parenthesis search
        Letter: e, Word: 
        Letter: 2, Word: e
        Letter: ), Word: e2
        Stop search for parenthesis
      Iteration count changed from 247 to 258
      Instruction: `(e2) =>`
    Letter: ; Mapped Word: ;
    Updated caret 259
    Start name search: const test3 =, 5
      Letter:  
      Letter: t
      Letter: e
      Letter: s
      Letter: t
      Letter: 3
      Letter:  
      Letter: =
      Blocks name: test3
    Iteration count changed from 232 to 259
    Instruction: `const test3 =`
  Letter:   Mapped Word:  
  Letter: l Mapped Word: l
  Letter: e Mapped Word: le
  Letter: t Mapped Word: let
  Letter:   Mapped Word: let 
    New block: Variable Mapped by: let 
    Letter:   end chars: =
    Letter: l end chars: =
    Letter: o end chars: =
    Letter: n end chars: =
    Letter: g end chars: =
    Letter: N end chars: =
    Letter: a end chars: =
    Letter: m end chars: =
    Letter: e end chars: =
    Letter: L end chars: =
    Letter: e end chars: =
    Letter: t end chars: =
    Letter:   end chars: =
    Letter: = end chars: =
    Proper end : 277
    Found instruction: let longNameLet =
    Letter:   Mapped Word:  
    Letter: ` Mapped Word: `
    Letter: a Mapped Word: a
    Letter: s Mapped Word: s
    Letter: d Mapped Word: d
    Letter:   Mapped Word:  
    Letter: $ Mapped Word: $
    Letter: { Mapped Word: {
    Letter: t Mapped Word: t
    Letter: e Mapped Word: e
    Letter: s Mapped Word: s
    Letter: t Mapped Word: t
    Letter: I Mapped Word: I
    Letter: n Mapped Word: n
    Letter: l Mapped Word: nl
    Letter: i Mapped Word: nli
    Letter: n Mapped Word: n
    Letter: e Mapped Word: ne
    Letter: } Mapped Word: ne}
    Letter:   Mapped Word:  
    Letter: a Mapped Word: a
    Letter: s Mapped Word: s
    Letter: d Mapped Word: d
    Letter: a Mapped Word: a
    Letter: s Mapped Word: s
    Letter: d Mapped Word: d
    Letter: ` Mapped Word: `
    Letter: \n Mapped Word: \n
    Updated caret 305
    Start name search: let longNameLet =, 3
      Letter:  
      Letter: l
      Letter: o
      Letter: n
      Letter: g
      Letter: N
      Letter: a
      Letter: m
      Letter: e
      Letter: L
      Letter: e
      Letter: t
      Letter:  
      Letter: =
      Blocks name: longNameLet
    Iteration count changed from 264 to 305
    Instruction: `let longNameLet =`
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter: c Mapped Word: c
  Letter: o Mapped Word: co
  Letter: n Mapped Word: con
  Letter: s Mapped Word: cons
  Letter: o Mapped Word: conso
  Letter: l Mapped Word: l
  Letter: e Mapped Word: le
  Letter: . Mapped Word: le.
    New block: ChainLink Mapped by: le.
    Find start of instruction. End: 317
    Letter: e
    Letter: l
    Letter: o
    Letter: s
    Letter: n
    Letter: o
    Letter: c
    Letter:  
    Proper start : 309
    Start search for end of link
      Letter: l
      Letter: o
      Letter: g
      Letter: (
      End found: (
    Instruction: log
    Letter: t Mapped Word: t
    Letter: e Mapped Word: e
    Letter: s Mapped Word: s
    Letter: t Mapped Word: t
    Letter: 3 Mapped Word: 3
    Letter: ( Mapped Word: (
      New block: Caller Mapped by: (
      Iteration count changed from 327 to 331
      Instruction: `test3('s')`
    Letter: ) Mapped Word: )
    Updated caret 332
    Iteration count changed from 317 to 332
    Instruction: `log`
  Letter: ; Mapped Word: ;
  Undefined check for: ;
  Letter: \n Mapped Word: \n
  Undefined check for: \n
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter: c Mapped Word: c
  Letter: o Mapped Word: co
  Letter: n Mapped Word: con
  Letter: s Mapped Word: cons
  Letter: t Mapped Word: const
  Letter:   Mapped Word: const 
    New block: Variable Mapped by: const 
    Letter:   end chars: =
    Letter: l end chars: =
    Letter: o end chars: =
    Letter: n end chars: =
    Letter: g end chars: =
    Letter: N end chars: =
    Letter: a end chars: =
    Letter: m end chars: =
    Letter: e end chars: =
    Letter: C end chars: =
    Letter: o end chars: =
    Letter: n end chars: =
    Letter: s end chars: =
    Letter: t end chars: =
    Letter:   end chars: =
    Letter: = end chars: =
    Proper end : 359
    Found instruction: const longNameConst =
    Letter:   Mapped Word:  
    Letter: [ Mapped Word: [
    Letter: ' Mapped Word: '
    Letter: a Mapped Word: a
    Letter: s Mapped Word: s
    Letter: d Mapped Word: d
    Letter: ' Mapped Word: '
    Letter: , Mapped Word: ,
    Letter: ' Mapped Word: '
    Letter: a Mapped Word: a
    Letter: s Mapped Word: s
    Letter: d Mapped Word: d
    Letter: s Mapped Word: s
    Letter: a Mapped Word: a
    Letter: d Mapped Word: d
    Letter: ' Mapped Word: '
    Letter: ] Mapped Word: ]
    Letter: ; Mapped Word: ;
    Updated caret 377
    Start name search: const longNameConst =, 5
      Letter:  
      Letter: l
      Letter: o
      Letter: n
      Letter: g
      Letter: N
      Letter: a
      Letter: m
      Letter: e
      Letter: C
      Letter: o
      Letter: n
      Letter: s
      Letter: t
      Letter:  
      Letter: =
      Blocks name: longNameConst
    Iteration count changed from 344 to 377
    Instruction: `const longNameConst =`
  Letter: \n Mapped Word: \n
  Undefined check for: \n
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter: v Mapped Word: v
  Letter: a Mapped Word: va
  Letter: r Mapped Word: var
  Letter:   Mapped Word: var 
    New block: Variable Mapped by: var 
    Letter:   end chars: =
    Letter: t end chars: =
    Letter: e end chars: =
    Letter: s end chars: =
    Letter: t end chars: =
    Letter: I end chars: =
    Letter: n end chars: =
    Letter: l end chars: =
    Letter: i end chars: =
    Letter: n end chars: =
    Letter: e end chars: =
    Letter:   end chars: =
    Letter: = end chars: =
    Proper end : 398
    Found instruction: var testInline =
    Letter:   Mapped Word:  
    Letter: 2 Mapped Word: 2
    Letter: 0 Mapped Word: 0
    Letter: ; Mapped Word: ;
    Updated caret 402
    Start name search: var testInline =, 3
      Letter:  
      Letter: t
      Letter: e
      Letter: s
      Letter: t
      Letter: I
      Letter: n
      Letter: l
      Letter: i
      Letter: n
      Letter: e
      Letter:  
      Letter: =
      Blocks name: testInline
    Iteration count changed from 386 to 402
    Instruction: `var testInline =`
  Letter:   Mapped Word:  
  Letter: l Mapped Word: l
  Letter: e Mapped Word: le
  Letter: t Mapped Word: let
  Letter:   Mapped Word: let 
    New block: Variable Mapped by: let 
    Letter:   end chars: =
    Letter: t end chars: =
    Letter: e end chars: =
    Letter: s end chars: =
    Letter: t end chars: =
    Letter: I end chars: =
    Letter: n end chars: =
    Letter: l end chars: =
    Letter: i end chars: =
    Letter: n end chars: =
    Letter: e end chars: =
    Letter: 2 end chars: =
    Letter:   end chars: =
    Letter: = end chars: =
    Proper end : 420
    Found instruction: let testInline2 =
    Letter:   Mapped Word:  
    Letter: { Mapped Word: {
    Letter: ' Mapped Word: '
    Letter: a Mapped Word: a
    Letter: ' Mapped Word: '
    Letter:   Mapped Word:  
    Letter: : Mapped Word: :
    Letter:   Mapped Word:  
    Letter: ' Mapped Word: '
    Letter: s Mapped Word: s
    Letter: d Mapped Word: d
    Letter: ' Mapped Word: '
    Letter: } Mapped Word: }
    Letter: \n Mapped Word: \n
    Updated caret 434
    Start name search: let testInline2 =, 3
      Letter:  
      Letter: t
      Letter: e
      Letter: s
      Letter: t
      Letter: I
      Letter: n
      Letter: l
      Letter: i
      Letter: n
      Letter: e
      Letter: 2
      Letter:  
      Letter: =
      Blocks name: testInline2
    Iteration count changed from 407 to 434
    Instruction: `let testInline2 =`
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter: c Mapped Word: c
  Letter: o Mapped Word: co
  Letter: n Mapped Word: con
  Letter: s Mapped Word: cons
  Letter: t Mapped Word: const
  Letter:   Mapped Word: const 
    New block: Variable Mapped by: const 
    Letter:   end chars: =
    Letter: t end chars: =
    Letter: e end chars: =
    Letter: s end chars: =
    Letter: t end chars: =
    Letter: A end chars: =
    Letter: d end chars: =
    Letter: d end chars: =
    Letter: A end chars: =
    Letter: l end chars: =
    Letter: i end chars: =
    Letter: a end chars: =
    Letter: s end chars: =
    Letter: e end chars: =
    Letter: s end chars: =
    Letter:   end chars: =
    Letter: = end chars: =
    Proper end : 460
    Found instruction: const testAddAliases =
    Letter:   Mapped Word:  
    Letter: l Mapped Word: l
    Letter: o Mapped Word: lo
    Letter: n Mapped Word: n
    Letter: g Mapped Word: ng
    Letter: N Mapped Word: N
    Letter: a Mapped Word: a
    Letter: m Mapped Word: m
    Letter: e Mapped Word: e
    Letter: L Mapped Word: L
    Letter: e Mapped Word: e
    Letter: t Mapped Word: t
    Letter:   Mapped Word:  
    Letter: + Mapped Word: +
    Letter:   Mapped Word:  
    Letter: t Mapped Word: t
    Letter: e Mapped Word: e
    Letter: s Mapped Word: s
    Letter: t Mapped Word: t
    Letter: I Mapped Word: I
    Letter: n Mapped Word: n
    Letter: l Mapped Word: nl
    Letter: i Mapped Word: nli
    Letter: n Mapped Word: n
    Letter: e Mapped Word: ne
    Letter: \n Mapped Word: ne\n
    Updated caret 486
    Start name search: const testAddAliases =, 5
      Letter:  
      Letter: t
      Letter: e
      Letter: s
      Letter: t
      Letter: A
      Letter: d
      Letter: d
      Letter: A
      Letter: l
      Letter: i
      Letter: a
      Letter: s
      Letter: e
      Letter: s
      Letter:  
      Letter: =
      Blocks name: testAddAliases
    Iteration count changed from 444 to 486
    Instruction: `const testAddAliases =`
  Letter: } Mapped Word: }
  Updated caret 487
  Iteration count changed from 8 to 487
  Instruction: `function test() {`
Letter: \n Mapped Word: \n
Undefined check for: \n
Letter: \n Mapped Word: \n
Undefined check for: \n
Letter: t Mapped Word: t
Letter: e Mapped Word: e
Letter: s Mapped Word: s
Letter: t Mapped Word: t
Letter: a Mapped Word: a
Letter: = Mapped Word: =
Letter: ' Mapped Word: ='
  New block: Attribute Mapped by: =
    Letter: a
    Found closest letter, search for white space: 
    Letter: t
    Found closest letter, search for white space: 
    Letter: s
    Found closest letter, search for white space: 
    Letter: e
    Found closest letter, search for white space: 
    Letter: t
    Found closest letter, search for white space: 
    Letter: \n
    Start found: 495
  Letter: \n end chars: =
  Letter: t end chars: =
  Letter: e end chars: =
  Letter: s end chars: =
  Letter: t end chars: =
  Letter: a end chars: =
  Letter: = end chars: =
  Proper end : 495
  Found instruction: testa=
  Letter: ' Mapped Word: '
  Letter: b Mapped Word: b
  Letter: ' Mapped Word: '
  Letter: \n Mapped Word: \n
  Updated caret 499
  Start name search: testa=, 0
    Letter: t
    Letter: e
    Letter: s
    Letter: t
    Letter: a
    Letter: =
    Blocks name: testa
  Iteration count changed from 495 to 499
  Instruction: `testa=`
Letter: \n Mapped Word: \n
Undefined check for: \n
Letter: e Mapped Word: e
Letter: 3 Mapped Word: 3
Letter: = Mapped Word: =
Letter: > Mapped Word: =>
  New block: ArrowMethod Mapped by: =>
  New Arrow method
    New letter `3`
    Start search for whitspace, letter found before bracket
    New letter `e`
    New letter `\n`
    White space found
  Start search for end
    Letter  
    Letter {
    Letter is bracket! Multi line function.
  Letter: \n Mapped Word: \n
  Undefined check for: \n
  Letter: \n Mapped Word: \n
  Undefined check for: \n
  Letter: } Mapped Word: }
  Updated caret 509
    Letter: e, Word: 
    function has only one arg, start search for it...
    Letter: 3, Word: e
    function has only one arg, start search for it...
    Letter: =, Word: e3
    function has only one arg, start search for it...
    Letter: >, Word: e3=
    function has only one arg, start search for it...
    Letter:  , Word: e3=>
    Whitespace!
    Found next whitespace, add arg and end iteration
  Iteration count changed from 504 to 509
  Instruction: `e3=> {`
Letter: \n Mapped Word: \n
Undefined check for: \n
Letter: \n Mapped Word: \n
Undefined check for: \n
Letter: c Mapped Word: c
Letter: l Mapped Word: cl
Letter: a Mapped Word: cla
Letter: s Mapped Word: clas
Letter: s Mapped Word: class
Letter:   Mapped Word: class 
  New block: Instance Mapped by: class 
  Letter:   end chars: {
  Letter: C end chars: {
  Letter: l end chars: {
  Letter: a end chars: {
  Letter: s end chars: {
  Letter: s end chars: {
  Letter: N end chars: {
  Letter: a end chars: {
  Letter: m end chars: {
  Letter: e end chars: {
  Letter:   end chars: {
  Letter: { end chars: {
  Proper end : 528
  Letter: \n Mapped Word: \n
  Undefined check for: \n
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter: p Mapped Word: p
  Letter: r Mapped Word: r
  Letter: o Mapped Word: o
  Letter: p Mapped Word: p
  Letter: e Mapped Word: e
  Letter: r Mapped Word: r
  Letter: t Mapped Word: t
  Letter: y Mapped Word: y
  Letter:   Mapped Word:  
  Letter: = Mapped Word: =
  Letter:   Mapped Word: = 
    New block: Attribute Mapped by: =
      Letter:  
      Letter: y
      Found closest letter, search for white space: 
      Letter: t
      Found closest letter, search for white space: 
      Letter: r
      Found closest letter, search for white space: 
      Letter: e
      Found closest letter, search for white space: 
      Letter: p
      Found closest letter, search for white space: 
      Letter: o
      Found closest letter, search for white space: 
      Letter: r
      Found closest letter, search for white space: 
      Letter: p
      Found closest letter, search for white space: 
      Letter:  
      Start found: 543
    Letter:   end chars: =
    Letter: p end chars: =
    Letter: r end chars: =
    Letter: o end chars: =
    Letter: p end chars: =
    Letter: e end chars: =
    Letter: r end chars: =
    Letter: t end chars: =
    Letter: y end chars: =
    Letter:   end chars: =
    Letter: = end chars: =
    Proper end : 543
    Found instruction: property =
    Letter:   Mapped Word:  
    Letter: ' Mapped Word: '
    Letter: a Mapped Word: a
    Letter: ' Mapped Word: '
    Letter: ; Mapped Word: ;
    Updated caret 548
    Start name search: property =, 0
      Letter: p
      Letter: r
      Letter: o
      Letter: p
      Letter: e
      Letter: r
      Letter: t
      Letter: y
      Letter:  
      Letter: =
      Blocks name: property
    Iteration count changed from 543 to 548
    Instruction: `property =`
  Letter: \n Mapped Word: \n
  Undefined check for: \n
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter: c Mapped Word: c
  Letter: o Mapped Word: co
  Letter: n Mapped Word: con
  Letter: s Mapped Word: cons
  Letter: t Mapped Word: const
  Letter: r Mapped Word: constr
  Letter: u Mapped Word: u
  Letter: c Mapped Word: c
  Letter: t Mapped Word: ct
  Letter: o Mapped Word: o
  Letter: r Mapped Word: r
  Letter: ( Mapped Word: (
    New block: InstanceMethod Mapped by: (
    Letter: c end chars: {
    Letter: o end chars: {
    Letter: n end chars: {
    Letter: s end chars: {
    Letter: t end chars: {
    Letter: r end chars: {
    Letter: u end chars: {
    Letter: c end chars: {
    Letter: t end chars: {
    Letter: o end chars: {
    Letter: r end chars: {
    Letter: ( end chars: {
    Letter: a end chars: {
    Letter: r end chars: {
    Letter: g end chars: {
    Letter: 1 end chars: {
    Letter: , end chars: {
    Letter:   end chars: {
    Letter: a end chars: {
    Letter: r end chars: {
    Letter: g end chars: {
    Letter: 2 end chars: {
    Letter: ) end chars: {
    Letter:   end chars: {
    Letter: { end chars: {
    Proper end : 578
    Start name search: constructor(arg1, arg2) {, 0
      Letter: c
      Letter: o
      Letter: n
      Letter: s
      Letter: t
      Letter: r
      Letter: u
      Letter: c
      Letter: t
      Letter: o
      Letter: r
      Letter: (
      Blocks name: constructor
    Letter: \n Mapped Word: \n
    Undefined check for: \n
    Letter: \n Mapped Word: \n
    Undefined check for: \n
    Letter:   Mapped Word:  
    Letter:   Mapped Word:  
    Letter:   Mapped Word:  
    Letter:   Mapped Word:  
    Letter: } Mapped Word: }
    Updated caret 585
    Iteration count changed from 565 to 585
    Instruction: `constructor(arg1, arg2) {`
  Letter: \n Mapped Word: \n
  Undefined check for: \n
  Letter: \n Mapped Word: \n
  Undefined check for: \n
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter:   Mapped Word:  
  Letter: f Mapped Word: f
  Letter: u Mapped Word: fu
  Letter: n Mapped Word: fun
  Letter: c Mapped Word: func
  Letter: ( Mapped Word: func(
    New block: InstanceMethod Mapped by: func(
    Letter: f end chars: {
    Letter: u end chars: {
    Letter: n end chars: {
    Letter: c end chars: {
    Letter: ( end chars: {
    Letter: ) end chars: {
    Letter:   end chars: {
    Letter: { end chars: {
    Proper end : 599
    Start name search: func() {, 0
      Letter: f
      Letter: u
      Letter: n
      Letter: c
      Letter: (
      Blocks name: func
    Letter: \n Mapped Word: \n
    Undefined check for: \n
    Letter:   Mapped Word:  
    Letter:   Mapped Word:  
    Letter:   Mapped Word:  
    Letter:   Mapped Word:  
    Letter:   Mapped Word:  
    Letter:   Mapped Word:  
    Letter:   Mapped Word:  
    Letter:   Mapped Word:  
    Letter: c Mapped Word: c
    Letter: o Mapped Word: co
    Letter: n Mapped Word: con
    Letter: s Mapped Word: cons
    Letter: o Mapped Word: conso
    Letter: l Mapped Word: l
    Letter: e Mapped Word: le
    Letter: . Mapped Word: le.
      New block: ChainLink Mapped by: le.
      Find start of instruction. End: 616
      Letter: e
      Letter: l
      Letter: o
      Letter: s
      Letter: n
      Letter: o
      Letter: c
      Letter:  
      Proper start : 608
      Start search for end of link
        Letter: l
        Letter: o
        Letter: g
        Letter: (
        End found: (
      Instruction: log
      Letter: t Mapped Word: t
      Letter: h Mapped Word: h
      Letter: i Mapped Word: i
      Letter: s Mapped Word: s
      Letter: . Mapped Word: .
        New block: ChainLink Mapped by: .
        Find start of instruction. End: 625
        Letter: s
        Letter: i
        Letter: h
        Letter: t
        Letter: (
        Proper start : 620
        Start search for end of link
          Letter: p
          Letter: r
          Letter: o
          Letter: p
          Letter: e
          Letter: r
          Letter: t
          Letter: y
          Letter: )
          End found: )
        Instruction: property
        Iteration count changed from 625 to 633
        Instruction: `property`
      Letter: ) Mapped Word: )
      Updated caret 634
      Iteration count changed from 616 to 634
      Instruction: `log`
    Letter: ; Mapped Word: ;
    Undefined check for: ;
    Letter: \n Mapped Word: \n
    Undefined check for: \n
    Letter:   Mapped Word:  
    Letter:   Mapped Word:  
    Letter:   Mapped Word:  
    Letter:   Mapped Word:  
    Letter: } Mapped Word: }
    Updated caret 641
    Iteration count changed from 596 to 641
    Instruction: `func() {`
  Letter: \n Mapped Word: \n
  Undefined check for: \n
  Letter: } Mapped Word: }
  Updated caret 643
  Start name search: class ClassName {, 5
    Letter:  
    Letter: C
    Letter: l
    Letter: a
    Letter: s
    Letter: s
    Letter: N
    Letter: a
    Letter: m
    Letter: e
    Letter:  
    Letter: {
    Blocks name: ClassName
  Iteration count changed from 517 to 643
  Instruction: `class ClassName {`
Letter: \n Mapped Word: \n
Undefined check for: \n
Letter: \n Mapped Word: \n
Undefined check for: \n
Letter: c Mapped Word: c
Letter: o Mapped Word: co
Letter: n Mapped Word: con
Letter: s Mapped Word: cons
Letter: t Mapped Word: const
Letter:   Mapped Word: const 
  New block: Variable Mapped by: const 
  Letter:   end chars: =
  Letter: c end chars: =
  Letter: l end chars: =
  Letter: a end chars: =
  Letter: s end chars: =
  Letter: s end chars: =
  Letter: N end chars: =
  Letter: a end chars: =
  Letter: m end chars: =
  Letter: e end chars: =
  Letter: I end chars: =
  Letter: n end chars: =
  Letter: s end chars: =
  Letter: t end chars: =
  Letter:   end chars: =
  Letter: = end chars: =
  Proper end : 666
  Found instruction: const classNameInst =
  Letter:   Mapped Word:  
  Letter: n Mapped Word: n
  Letter: e Mapped Word: ne
  Letter: w Mapped Word: new
  Letter:   Mapped Word: new 
    New block: NewInstance Mapped by: new 
    Iteration count changed from 671 to 692
    Instruction: ` ClassName('test', 2)`
  Letter: \n Mapped Word: \n
  Updated caret 693
  Start name search: const classNameInst =, 5
    Letter:  
    Letter: c
    Letter: l
    Letter: a
    Letter: s
    Letter: s
    Letter: N
    Letter: a
    Letter: m
    Letter: e
    Letter: I
    Letter: n
    Letter: s
    Letter: t
    Letter:  
    Letter: =
    Blocks name: classNameInst
  Iteration count changed from 651 to 693
  Instruction: `const classNameInst =`
Letter: c Mapped Word: c
Letter: l Mapped Word: cl
Letter: a Mapped Word: cla
Letter: s Mapped Word: clas
Letter: s Mapped Word: class
Letter: N Mapped Word: classN
Letter: a Mapped Word: a
Letter: m Mapped Word: m
Letter: e Mapped Word: e
Letter: I Mapped Word: I
Letter: n Mapped Word: n
Letter: s Mapped Word: ns
Letter: t Mapped Word: t
Letter: . Mapped Word: .
  New block: ChainLink Mapped by: .
  Find start of instruction. End: 707
  Letter: t
  Letter: s
  Letter: n
  Letter: I
  Letter: e
  Letter: m
  Letter: a
  Letter: N
  Letter: s
  Letter: s
  Letter: a
  Letter: l
  Letter: c
  Letter: \n
  Proper start : 693
  Start search for end of link
    Letter: f
    Letter: u
    Letter: n
    Letter: c
    Letter: (
    End found: (
  Instruction: func
  Letter: ) Mapped Word: )
  Updated caret 713
  Iteration count changed from 707 to 713
  Instruction: `func`
Letter: ; Mapped Word: ;
Undefined check for: ;
Letter: \n Mapped Word: \n
Undefined check for: \n
Updated caret 716
=======================
Creating aliases...
Start generating aliases. Last Alias: 
  ===========
  Block: test
  Generate alias for test
  Last alias: 
  Last letter: df
  Next sufix found: a
  New alias: a
  Generated Alias:a, previous alias: 
  Set generated alias.
  ===========
  Block: testa
  Generate alias for testa
  Last alias: a
  Last letter: a
  Next sufix found: b
  New alias: b
  Generated Alias:b, previous alias: a
  Set generated alias.
  ===========
  Block: 
  Generate alias for 
  Name is empty, skipping...
  Generated Alias:, previous alias: b
  skip alias.
  ===========
  Block: ClassName
  Generate alias for ClassName
  Last alias: b
  Last letter: b
  Next sufix found: c
  New alias: c
  Generated Alias:c, previous alias: b
  Set generated alias.
  ===========
  Block: classNameInst
  Generate alias for classNameInst
  Last alias: c
  Last letter: c
  Next sufix found: d
  New alias: d
  Generated Alias:d, previous alias: c
  Set generated alias.
  ===========
  Block: 
  Generate alias for 
  Name is empty, skipping...
  Generated Alias:, previous alias: d
  skip alias.
  ===========
  Block: 
  Generate alias for 
  Name is empty, skipping...
  Generated Alias:, previous alias: d
  skip alias.
  Start generating aliases. Last Alias: d
    ===========
    Block: longName
    Generate alias for longName
    Last alias: d
    Last letter: d
    Next sufix found: e
    New alias: e
    Generated Alias:e, previous alias: d
    Set generated alias.
    ===========
    Block: 
    Generate alias for 
    Name is empty, skipping...
    Generated Alias:, previous alias: e
    skip alias.
    ===========
    Block: 
    Generate alias for 
    Name is empty, skipping...
    Generated Alias:, previous alias: e
    skip alias.
    ===========
    Block: testa
    Alias for this block exists.
    ===========
    Block: test2
    Generate alias for test2
    Last alias: e
    Last letter: e
    Next sufix found: f
    New alias: f
    Generated Alias:f, previous alias: e
    Set generated alias.
    ===========
    Block: test3
    Generate alias for test3
    Last alias: f
    Last letter: f
    Next sufix found: g
    New alias: g
    Generated Alias:g, previous alias: f
    Set generated alias.
    ===========
    Block: longNameLet
    Generate alias for longNameLet
    Last alias: g
    Last letter: g
    Next sufix found: h
    New alias: h
    Generated Alias:h, previous alias: g
    Set generated alias.
    ===========
    Block: 
    Generate alias for 
    Name is empty, skipping...
    Generated Alias:, previous alias: h
    skip alias.
    ===========
    Block: 
    Generate alias for 
    Name is empty, skipping...
    Generated Alias:, previous alias: h
    skip alias.
    ===========
    Block: longNameConst
    Generate alias for longNameConst
    Last alias: h
    Last letter: h
    Next sufix found: i
    New alias: i
    Generated Alias:i, previous alias: h
    Set generated alias.
    ===========
    Block: testInline
    Generate alias for testInline
    Last alias: i
    Last letter: i
    Next sufix found: j
    New alias: j
    Generated Alias:j, previous alias: i
    Set generated alias.
    ===========
    Block: testInline2
    Generate alias for testInline2
    Last alias: j
    Last letter: j
    Next sufix found: k
    New alias: k
    Generated Alias:k, previous alias: j
    Set generated alias.
    ===========
    Block: testAddAliases
    Generate alias for testAddAliases
    Last alias: k
    Last letter: k
    Next sufix found: l
    New alias: l
    Generated Alias:l, previous alias: k
    Set generated alias.
  Block is an method.
    Start generating aliases. Last Alias: l
    Start generating aliases. Last Alias: l
    Start generating aliases. Last Alias: l
      ===========
      Block: 
      Generate alias for 
      Name is empty, skipping...
      Generated Alias:, previous alias: l
      skip alias.
      Start generating aliases. Last Alias: l
    Start generating aliases. Last Alias: l
      ===========
      Block: 
      Generate alias for 
      Name is empty, skipping...
      Generated Alias:, previous alias: l
      skip alias.
      ===========
      Block: 
      Generate alias for 
      Name is empty, skipping...
      Generated Alias:, previous alias: l
      skip alias.
      Start generating aliases. Last Alias: l
      Start generating aliases. Last Alias: l
        ===========
        Block: testScoped
        Generate alias for testScoped
        Last alias: l
        Last letter: l
        Next sufix found: m
        New alias: m
        Generated Alias:m, previous alias: l
        Set generated alias.
      Block is an method.
        Argument: arg1
        Generate alias for arg1
        Last alias: m
        Last letter: m
        Next sufix found: n
        New alias: n
        Generated alias: n, last alias: m
        Start generating aliases. Last Alias: n
          ===========
          Block: 
          Generate alias for 
          Name is empty, skipping...
          Generated Alias:, previous alias: n
          skip alias.
          Start generating aliases. Last Alias: n
          Block is an method.
            Argument: adas
            Generate alias for adas
            Last alias: n
            Last letter: n
            Next sufix found: o
            New alias: o
            Generated alias: o, last alias: n
            Argument: test5
            Generate alias for test5
            Last alias: o
            Last letter: o
            Next sufix found: p
            New alias: p
            Generated alias: p, last alias: o
            Argument: test4
            Generate alias for test4
            Last alias: p
            Last letter: p
            Next sufix found: r
            New alias: r
            Generated alias: r, last alias: p
            Argument: fgdfg
            Generate alias for fgdfg
            Last alias: r
            Last letter: r
            Next sufix found: s
            New alias: s
            Generated alias: s, last alias: r
    Start generating aliases. Last Alias: l
      ===========
      Block: 
      Generate alias for 
      Name is empty, skipping...
      Generated Alias:, previous alias: l
      skip alias.
      Start generating aliases. Last Alias: l
      Block is an method.
        Argument: e
        Generate alias for e
        Last alias: l
        Last letter: l
        Next sufix found: m
        New alias: m
        Generated alias: m, last alias: l
    Start generating aliases. Last Alias: l
      ===========
      Block: 
      Generate alias for 
      Name is empty, skipping...
      Generated Alias:, previous alias: l
      skip alias.
      ===========
      Block: 
      Generate alias for 
      Name is empty, skipping...
      Generated Alias:, previous alias: l
      skip alias.
      Start generating aliases. Last Alias: l
      Start generating aliases. Last Alias: l
      Block is an method.
        Argument: e2
        Generate alias for e2
        Last alias: l
        Last letter: l
        Next sufix found: m
        New alias: m
        Generated alias: m, last alias: l
    Start generating aliases. Last Alias: l
    Start generating aliases. Last Alias: l
    Start generating aliases. Last Alias: l
      ===========
      Block: 
      Generate alias for 
      Name is empty, skipping...
      Generated Alias:, previous alias: l
      skip alias.
      Start generating aliases. Last Alias: l
    Start generating aliases. Last Alias: l
    Start generating aliases. Last Alias: l
    Start generating aliases. Last Alias: l
    Start generating aliases. Last Alias: l
  Start generating aliases. Last Alias: d
  Start generating aliases. Last Alias: d
  Block is an method.
    Argument: e3=>
    Generate alias for e3=>
    Last alias: d
    Last letter: d
    Next sufix found: e
    New alias: e
    Generated alias: e, last alias: d
  Start generating aliases. Last Alias: d
    ===========
    Block: property
    Generate alias for property
    Last alias: d
    Last letter: d
    Next sufix found: e
    New alias: e
    Generated Alias:e, previous alias: d
    Set generated alias.
    ===========
    Block: constructor
    Generate alias for constructor
    Last alias: e
    Last letter: e
    Next sufix found: f
    New alias: f
    Generated Alias:f, previous alias: e
    Set generated alias.
    ===========
    Block: func
    Generate alias for func
    Last alias: f
    Last letter: f
    Next sufix found: g
    New alias: g
    Generated Alias:g, previous alias: f
    Set generated alias.
    Start generating aliases. Last Alias: g
    Start generating aliases. Last Alias: g
    Block is an method.
      Argument: arg1
      Argument already exists with this name.
      Argument: arg2
      Generate alias for arg2
      Last alias: g
      Last letter: g
      Next sufix found: h
      New alias: h
      Generated alias: h, last alias: g
    Start generating aliases. Last Alias: g
      ===========
      Block: 
      Generate alias for 
      Name is empty, skipping...
      Generated Alias:, previous alias: g
      skip alias.
      ===========
      Block: 
      Generate alias for 
      Name is empty, skipping...
      Generated Alias:, previous alias: g
      skip alias.
    Block is an method.
      Start generating aliases. Last Alias: g
      Start generating aliases. Last Alias: g
        ===========
        Block: 
        Generate alias for 
        Name is empty, skipping...
        Generated Alias:, previous alias: g
        skip alias.
        ===========
        Block: 
        Generate alias for 
        Name is empty, skipping...
        Generated Alias:, previous alias: g
        skip alias.
        Start generating aliases. Last Alias: g
        Start generating aliases. Last Alias: g
  Start generating aliases. Last Alias: d
    ===========
    Block: ClassName
    Alias for this block exists.
    Start generating aliases. Last Alias: d
    Block is an method.
      Argument: 'test'
      Generate alias for 'test'
      Last alias: d
      Last letter: d
      Next sufix found: e
      New alias: e
      Generated alias: e, last alias: d
      Argument: 2
      Generate alias for 2
      Last alias: e
      Last letter: e
      Next sufix found: f
      New alias: f
      Generated alias: f, last alias: e
  Start generating aliases. Last Alias: d
  Start generating aliases. Last Alias: d
=======================
Aliases: test => a, testa => b, ClassName => c, classNameInst => d, longName => e, test2 => f, test3 => g, longNameLet => h, longNameConst => i, testInline => j, testInline2 => k, testAddAliases => l, testScoped => m, arg1 => n, adas => o, test5 => p, test4 => r, fgdfg => s, e => m, e2 => m, e3=> => e, property => e, constructor => f, func => g, arg2 => h, 'test' => e, 2 => f, 
Recreating...
  Letter: 2 Word: 
  Letter: 0 Word: 2
  Letter: c Word: 
  Letter: o Word: c
  Letter: n Word: co
  Letter: s Word: con
  Letter: o Word: cons
  Letter: l Word: conso
  Letter: e Word: consol
  Letter: l Word: 
  Letter: o Word: l
  Letter: g Word: lo
  Letter: l Word: 
  Letter: o Word: l
  Letter: n Word: lo
  Letter: g Word: lon
  Letter: N Word: long
  Letter: a Word: longN
  Letter: m Word: longNa
  Letter: e Word: longNam
  Letter: 1 Word: 
  Letter:   Word: 1
  Alias: 1
  Letter: + Word: 
  Alias: 
  Letter:   Word: 
  Alias: 
  Letter: 2 Word: 
  Letter: 1 Word: 
  Letter:   Word: 1
  Alias: 1
  Letter: + Word: 
  Alias: 
  Letter:   Word: 
  Alias: 
  Letter: e Word: 
  Letter: 2 Word: e
  Letter: ` Word: 
  Letter: a Word: 
  Letter: s Word: 
  Letter: d Word: 
  Letter:   Word: 
  Letter: $ Word: 
  Letter: { Word: 
  Letter: t Word: 
  Literal in progress: t Word: 
  Letter: e Word: t
  Literal in progress: e Word: t
  Letter: s Word: te
  Literal in progress: s Word: te
  Letter: t Word: tes
  Literal in progress: t Word: tes
  Letter: I Word: test
  Literal in progress: I Word: test
  Letter: n Word: testI
  Literal in progress: n Word: testI
  Letter: l Word: testIn
  Literal in progress: l Word: testIn
  Letter: i Word: testInl
  Literal in progress: i Word: testInl
  Letter: n Word: testInli
  Literal in progress: n Word: testInli
  Letter: e Word: testInlin
  Literal in progress: e Word: testInlin
  Letter: } Word: testInline
  Literal in progress: } Word: testInline
  Add literal: } Word: testInline
  Alias: j
  Letter: a Word: 
  Letter: s Word: 
  Letter: d Word: 
  Letter: a Word: 
  Letter: s Word: 
  Letter: d Word: 
  Letter: ` Word: 
  Letter: c Word: 
  Letter: o Word: c
  Letter: n Word: co
  Letter: s Word: con
  Letter: o Word: cons
  Letter: l Word: conso
  Letter: e Word: consol
  Letter: l Word: 
  Letter: o Word: l
  Letter: g Word: lo
  Letter: t Word: 
  Letter: e Word: t
  Letter: s Word: te
  Letter: t Word: tes
  Letter: 3 Word: test
  Letter: ( Word: test3
  Alias: g
  Letter: ' Word: 
  Letter: s Word: 
  Letter: ' Word: 
  Letter: ) Word: '
  Alias: '
  Letter: [ Word: 
  Alias: 
  Letter: ' Word: 
  Letter: a Word: 
  Letter: s Word: 
  Letter: d Word: 
  Letter: ' Word: 
  Letter: , Word: '
  Alias: '
  Letter: ' Word: 
  Letter: a Word: 
  Letter: s Word: 
  Letter: d Word: 
  Letter: s Word: 
  Letter: a Word: 
  Letter: d Word: 
  Letter: ' Word: 
  Letter: ] Word: '
  Alias: '
  Letter: 2 Word: 
  Letter: 0 Word: 2
  Letter: { Word: 
  Alias: 
  Letter: ' Word: 
  Letter: a Word: 
  Letter: ' Word: 
  Letter: : Word: '
  Alias: '
  Letter: ' Word: 
  Letter: s Word: 
  Letter: d Word: 
  Letter: ' Word: 
  Letter: } Word: '
  Alias: '
  Letter: l Word: 
  Letter: o Word: l
  Letter: n Word: lo
  Letter: g Word: lon
  Letter: N Word: long
  Letter: a Word: longN
  Letter: m Word: longNa
  Letter: e Word: longNam
  Letter: L Word: longName
  Letter: e Word: longNameL
  Letter: t Word: longNameLe
  Letter: + Word: longNameLet
  Alias: h
  Letter: t Word: 
  Letter: e Word: t
  Letter: s Word: te
  Letter: t Word: tes
  Letter: I Word: test
  Letter: n Word: testI
  Letter: l Word: testIn
  Letter: i Word: testInl
  Letter: n Word: testInli
  Letter: e Word: testInlin
  Letter: ' Word: 
  Letter: b Word: 
  Letter: ' Word: 
  Letter: ' Word: 
  Letter: a Word: 
  Letter: ' Word: 
  Letter: c Word: 
  Letter: o Word: c
  Letter: n Word: co
  Letter: s Word: con
  Letter: o Word: cons
  Letter: l Word: conso
  Letter: e Word: consol
  Letter: l Word: 
  Letter: o Word: l
  Letter: g Word: lo
  Letter: t Word: 
  Letter: h Word: t
  Letter: i Word: th
  Letter: s Word: thi
  Letter: p Word: 
  Letter: r Word: p
  Letter: o Word: pr
  Letter: p Word: pro
  Letter: e Word: prop
  Letter: r Word: prope
  Letter: t Word: proper
  Letter: y Word: propert
  Letter: c Word: 
  Letter: l Word: c
  Letter: a Word: cl
  Letter: s Word: cla
  Letter: s Word: clas
  Letter: N Word: class
  Letter: a Word: classN
  Letter: m Word: classNa
  Letter: e Word: classNam
  Letter: I Word: className
  Letter: n Word: classNameI
  Letter: s Word: classNameIn
  Letter: t Word: classNameIns
  Letter: f Word: 
  Letter: u Word: f
  Letter: n Word: fu
  Letter: c Word: fun
=======================
Block: Tetraquark\Block\Method
Subtype: function
Instruction: function test() {
Name: `test`
Arguments: [0] ``
Alias: `a`
=======
  Block: Tetraquark\Block\Variable
  Subtype: var
  Instruction: var longName =
  Name: `longName`
  Value: `20`
  Alias: `e`
  =======
  Block: Tetraquark\Block\ChainLink
  Subtype: first
  Instruction: console
  Name: ``
  Alias: ``
  =======
  Block: Tetraquark\Block\ChainLink
  Subtype: end:method
  Instruction: log
  Name: ``
  Alias: ``
  =======
    Block: Tetraquark\Block\Undefined
    Subtype: 
    Instruction: longName
    Name: ``
    Alias: ``
    =======
  Block: Tetraquark\Block\Variable
  Subtype: const
  Instruction: const testa =
  Name: `testa`
  Value: ``
  Alias: `b`
  =======
    Block: Tetraquark\Block\Caller
    Subtype: (
    Instruction: 
    Name: ``
    Alias: ``
    =======
    Block: Tetraquark\Block\ArrowMethod
    Subtype: parenthesis:brackets
    Instruction: (arg1) => {
    Name: ``
    Value: ``
    Arguments: [1] `arg1`
    Alias: ``
    =======
      Block: Tetraquark\Block\Variable
      Subtype: const
      Instruction: const testScoped =
      Name: `testScoped`
      Value: ``
      Alias: `m`
      =======
        Block: Tetraquark\Block\Method
        Subtype: anonymous:function
        Instruction: function (adas, test5 , test4, fgdfg) {
        Name: ``
        Arguments: [4] `adas`, `test5`, `test4`, `fgdfg`
        Alias: ``
        =======
  Block: Tetraquark\Block\Variable
  Subtype: const
  Instruction: const test2 =
  Name: `test2`
  Value: ``
  Alias: `f`
  =======
    Block: Tetraquark\Block\ArrowMethod
    Subtype: no-parenthesis:no-brackets
    Instruction: e =>
    Name: ``
    Value: `1 + 2`
    Arguments: [1] `e`
    Alias: ``
    =======
  Block: Tetraquark\Block\Variable
  Subtype: const
  Instruction: const test3 =
  Name: `test3`
  Value: ``
  Alias: `g`
  =======
    Block: Tetraquark\Block\Caller
    Subtype: (
    Instruction: 
    Name: ``
    Alias: ``
    =======
    Block: Tetraquark\Block\ArrowMethod
    Subtype: parenthesis:no-brackets
    Instruction: (e2) =>
    Name: ``
    Value: `1 + e2`
    Arguments: [1] `e2`
    Alias: ``
    =======
  Block: Tetraquark\Block\Variable
  Subtype: let
  Instruction: let longNameLet =
  Name: `longNameLet`
  Value: ``asd ${testInline} asdasd``
  Alias: `h`
  =======
  Block: Tetraquark\Block\ChainLink
  Subtype: first
  Instruction: console
  Name: ``
  Alias: ``
  =======
  Block: Tetraquark\Block\ChainLink
  Subtype: end:method
  Instruction: log
  Name: ``
  Alias: ``
  =======
    Block: Tetraquark\Block\Caller
    Subtype: (
    Instruction: test3('s')
    Name: ``
    Alias: ``
    =======
  Block: Tetraquark\Block\Variable
  Subtype: const
  Instruction: const longNameConst =
  Name: `longNameConst`
  Value: `['asd','asdsad']`
  Alias: `i`
  =======
  Block: Tetraquark\Block\Variable
  Subtype: var
  Instruction: var testInline =
  Name: `testInline`
  Value: `20`
  Alias: `j`
  =======
  Block: Tetraquark\Block\Variable
  Subtype: let
  Instruction: let testInline2 =
  Name: `testInline2`
  Value: `{'a' : 'sd'}`
  Alias: `k`
  =======
  Block: Tetraquark\Block\Variable
  Subtype: const
  Instruction: const testAddAliases =
  Name: `testAddAliases`
  Value: `longNameLet + testInline`
  Alias: `l`
  =======
Block: Tetraquark\Block\Attribute
Subtype: 
Instruction: testa=
Name: `testa`
Value: `'b'`
Alias: `b`
=======
Block: Tetraquark\Block\ArrowMethod
Subtype: no-parenthesis:brackets
Instruction: e3=> {
Name: ``
Value: ``
Arguments: [1] `e3=>`
Alias: ``
=======
Block: Tetraquark\Block\Instance
Subtype: class
Instruction: class ClassName {
Name: `ClassName`
Alias: `c`
=======
  Block: Tetraquark\Block\Attribute
  Subtype: 
  Instruction: property =
  Name: `property`
  Value: `'a'`
  Alias: `e`
  =======
  Block: Tetraquark\Block\InstanceMethod
  Subtype: method
  Instruction: constructor(arg1, arg2) {
  Name: `constructor`
  Arguments: [2] `arg1`, `arg2`
  Alias: `f`
  =======
  Block: Tetraquark\Block\InstanceMethod
  Subtype: method
  Instruction: func() {
  Name: `func`
  Arguments: [0] ``
  Alias: `g`
  =======
    Block: Tetraquark\Block\ChainLink
    Subtype: first
    Instruction: console
    Name: ``
    Alias: ``
    =======
    Block: Tetraquark\Block\ChainLink
    Subtype: end:method
    Instruction: log
    Name: ``
    Alias: ``
    =======
      Block: Tetraquark\Block\ChainLink
      Subtype: first
      Instruction: this
      Name: ``
      Alias: ``
      =======
      Block: Tetraquark\Block\ChainLink
      Subtype: .
      Instruction: property
      Name: ``
      Alias: ``
      =======
Block: Tetraquark\Block\Variable
Subtype: const
Instruction: const classNameInst =
Name: `classNameInst`
Value: ``
Alias: `d`
=======
  Block: Tetraquark\Block\NewInstance
  Subtype: new
  Instruction:  ClassName('test', 2)
  Name: `ClassName`
  Arguments: [2] `'test'`, `2`
  Alias: `c`
  =======
Block: Tetraquark\Block\ChainLink
Subtype: first
Instruction: classNameInst
Name: ``
Alias: ``
=======
Block: Tetraquark\Block\ChainLink
Subtype: end:method
Instruction: func
Name: ``
Alias: ``
=======
Duration: 0.014s


function a(){var e=20;console.log(e);const b=(n)=>{const m=function (o,p,r,s){}};const f=(m)=>1+f;const g=(m)=>1+m;let h=`asd ${j}asdasd`;console.log(g('s'));const i=['asd','asdsad'];var j=20;let k={'a':'sd'};const l=h+j;} b='b';(e)=>{};class c{ e='a';f(n,h){}g(){console.log(this.e);}}const d=new c('test',2);d.g();
