Mapping...
-======
Letter: .
Letter: .
Letter: .
Letter: a
Letter: r
Letter: g
Letter: s
Letter: )
This might be arrow method, search for arrow
Letter:  
Whitespace
Letter: =
Arrow function found
-======
Letter: t
Letter: i
Letter: m
Letter: e
Letter: r
Letter: )
This might be arrow method, search for arrow
Letter: ;
Start search for end of call 2
Instruction starts at 1450 and ends at 1457 => (timer)
-======
Letter: (
Letter: )
Letter:  
Whitespace
Letter: =
Start the skip of default definition
Letter: >
Skip letter and find end of default deinfinition
Letter:  
Whitespace
Letter: {
Skip letter and find end of default deinfinition
Letter:  
Whitespace
Letter: f
Skip letter and find end of default deinfinition
Letter: u
Skip letter and find end of default deinfinition
Letter: n
Skip letter and find end of default deinfinition
Letter: c
Skip letter and find end of default deinfinition
Letter: .
Skip letter and find end of default deinfinition
Letter: a
Skip letter and find end of default deinfinition
Letter: p
Skip letter and find end of default deinfinition
Letter: p
Skip letter and find end of default deinfinition
Letter: l
Skip letter and find end of default deinfinition
Letter: y
Skip letter and find end of default deinfinition
Letter: (
Letter: t
Skip letter and find end of default deinfinition
Letter: h
Skip letter and find end of default deinfinition
Letter: i
Skip letter and find end of default deinfinition
Letter: s
Skip letter and find end of default deinfinition
Letter: ,
Default definintion end found
Letter:  
Whitespace
Letter: a
Letter: r
Letter: g
Letter: s
Letter: )
Letter: ;
Letter:  
Whitespace
Letter: }
Letter: ,
Letter:  
Whitespace
Letter: t
Letter: i
Letter: m
Letter: e
Letter: o
Letter: u
Letter: t
Letter: )
This might be arrow method, search for arrow
Letter: ;
Start search for end of call 2
Instruction starts at 1585 and ends at 1629 => (() => { func.apply(this, args); }, timeout)
=======================
Creating aliases...
=======================
Aliases: TabJF_Hidden => a, debounce => b, timer => c, func => d, timeout => e, if => f, args => g, 
Recreating...
arrow function args: 1
=======================
Block: Tetraquark\Block\MultiCommentBlock
Subtype: /*
Instruction: /**\n * Hidden class is used to hide some methods from debug tool which monitors how script behaves by attaching Proxy to all methods and attrbiutes\n * (omiting those starting with `_`).\n */
Instruction Start: 0
Name: ``
Alias: ``
=======
Block: Tetraquark\Block\ClassBlock
Subtype: class
Instruction: class TabJF_Hidden {
Instruction Start: 190
Name: `TabJF_Hidden`
Alias: `a`
=======
  Block: Tetraquark\Block\MultiCommentBlock
  Subtype: /*
  Instruction: /**\n   * Debounce factory.\n   * Passed function here will be fired after set `timeout` but the timeout will be postponed for another `timeout` value each time returned\n   * method was called.\n   * Example:\n   *\n   * this.debounceTest = this.debounce(countdown, 200);      // Create debounce function\n   * this.debounceTest();                                    // Start the timer to fire `countdown` after 200ms\n   * ... // 10ms later\n   * this.debounceTest();                                    // Reset timer to fire `countdown` after 200ms from now so it 210ms from the\n   *                                                         // first time `countdown` was called\n   *\n   * In case you started the countdown and want to prevent it can call returned function again with `clear` as first argument. This will clear\n   * the timeout. Example:\n   * \n   * this.debounceTest('clear');\n   *\n   * @param  {function} func          Function to fire\n   * @param  {Number  } [timeout=300] Timeout after function should be called\n   * @return {function}               The debounce function to call if you want to start or postpone saved method\n   */
  Instruction Start: 213
  Name: ``
  Alias: ``
  =======
  Block: Tetraquark\Block\ClassMethodBlock
  Subtype: method
  Instruction: debounce (func, timeout = 300) {
  Instruction Start: 1358
  Name: `debounce`
  Arguments: [2] `
    Block: Tetraquark\Block\UndefinedBlock
    Subtype: 
    Instruction: func
    Instruction Start: 0
    Name: `func`
    Alias: `d`
    =======
    Block: Tetraquark\Block\AttributeBlock
    Subtype: 
    Instruction:  timeout =
    Instruction Start: 0
    Name: `timeout`
    Value: ``
    Alias: `e`
    =======
      Block: Tetraquark\Block\UndefinedBlock
      Subtype: 
      Instruction:  300
      Instruction Start: 10
      Name: ``
      Alias: ``
      =======
  Alias: `b`
  =======
    Block: Tetraquark\Block\VariableBlock
    Subtype: let
    Instruction: 
    Instruction Start: 1404
    Name: `timer`
    Value: ``
    Alias: `c`
    =======
    Block: Tetraquark\Block\UndefinedBlock
    Subtype: 
    Instruction:     return 
    Instruction Start: 1406
    Name: ``
    Alias: ``
    =======
    Block: Tetraquark\Block\CallerBlock
    Subtype: (
    Instruction: 
    Instruction Start: 1417
    Name: ``
    Alias: ``
    =======
      Block: Tetraquark\Block\ArrowFunctionBlock
      Subtype: parenthesis:brackets
      Instruction: (...args) => {
      Instruction Start: 1417
      Name: ``
      Value: ``
      Arguments: [1] `
        Block: Tetraquark\Block\SpreadBlock
        Subtype: ...
        Instruction: ...
        Instruction Start: 2
        Name: ``
        Alias: ``
        =======
        Block: Tetraquark\Block\UndefinedBlock
        Subtype: 
        Instruction: args
        Instruction Start: 3
        Name: `args`
        Alias: `g`
        =======
      Alias: ``
      =======
        Block: Tetraquark\Block\UndefinedBlock
        Subtype: 
        Instruction: \n      clearTimeout
        Instruction Start: 1431
        Name: ``
        Alias: ``
        =======
        Block: Tetraquark\Block\CallerBlock
        Subtype: (
        Instruction: (timer)
        Instruction Start: 1450
        Name: ``
        Alias: ``
        =======
        Block: Tetraquark\Block\IfBlock
        Subtype: if
        Instruction:  if ( args[0] === "clear" ) {
        Instruction Start: 1464
        Name: `if`
        Alias: `f`
        =======
          Block: Tetraquark\Block\UndefinedBlock
          Subtype: 
          Instruction: \n        return; 
          Instruction Start: 1494
          Name: ``
          Alias: ``
          =======
          Block: Tetraquark\Block\SingleCommentBlock
          Subtype: //
          Instruction: / if passed `clear` then stop debouncing\n
          Instruction Start: 1511
          Name: ``
          Alias: ``
          =======
        Block: Tetraquark\Block\AttributeBlock
        Subtype: 
        Instruction:  timer =
        Instruction Start: 1566
        Name: `timer`
        Value: ``
        Alias: `c`
        =======
          Block: Tetraquark\Block\UndefinedBlock
          Subtype: 
          Instruction:  setTimeout
          Instruction Start: 1574
          Name: ``
          Alias: ``
          =======
          Block: Tetraquark\Block\CallerBlock
          Subtype: (
          Instruction: (() => { func.apply(this, args); }, timeout)
          Instruction Start: 1585
          Name: ``
          Alias: ``
          =======
Block: Tetraquark\Block\UndefinedBlock
Subtype: 
Instruction: \nexport 
Instruction Start: 1643
Name: ``
Alias: ``
=======
Block: Tetraquark\Block\ObjectBlock
Subtype: {
Instruction: 
Instruction Start: 1651
Name: ``
Alias: ``
=======
  Block: Tetraquark\Block\UndefinedBlock
  Subtype: 
  Instruction:  TabJF_Hidden 
  Instruction Start: 1652
  Name: ``
  Alias: ``
  =======
Duration: 0.014s


class a{b(d,e=300){let c;return(...g)=>{clearTimeout(c);if(g[0]==="clear"){return;}c=setTimeout(()=>{d.apply(this,g);},e);};}}export{a};
